    ; simple tests of each operator
    DW  +0x1234, -0x1234
    DW  ~0x1234
    DW  !0x1234, not 0x1234
    DW  low 0x1234, high 0x1234
    DW  0x123 + 0x4560, 0x123 - 0x4560
    DW  0x12 * 0x34, 0x3456 / 0x12
    DW  0x3456 % 0x12, 0x3456 mod 0x12
    DW  0x1234 << 3, 0x1234 shl 3
    DW  -17768 >> 3, -17768 shr 3   ; -17768 = 0xFFFFBA98
    DW  0xBA98 >> 3, 0xBA98 shr 3   ; expressions are calculated in 32b! 0xBA98 => positive
    DW  -17768 >>> 3, 0xBA98 >>> 3  ; first is bug! should be 0x1F'FF'F7'53
    DW  0x1234 & 0x5678, 0x5678 and 0x1234
    DW  0x1234 ^ 0x5678, 0x5678 xor 0x1234
    DW  0x1234 | 0x5678, 0x5678 or 0x1234
    DW  0x1234 <? 0x5678, 0x5678 <? 0x1234
    DW  0x1234 >? 0x5678, 0x5678 >? 0x1234
    DB  0x1234 < 0x5678, 0x5678 < 0x1234, 0x1234 < 0x1234
    DB  0x1234 > 0x5678, 0x5678 > 0x1234, 0x1234 > 0x1234
    DB  0x1234 <= 0x5678, 0x5678 <= 0x1234, 0x1234 <= 0x1234
    DB  0x1234 >= 0x5678, 0x5678 >= 0x1234, 0x1234 >= 0x1234
    DB  0x1234 = 0x5678, 0x5678 = 0x1234, 0x1234 = 0x1234
    DB  0x1234 == 0x5678, 0x5678 == 0x1234, 0x1234 == 0x1234
    DB  0x1234 != 0x5678, 0x5678 != 0x1234, 0x1234 != 0x1234
    DB  0x0012 && 0x3400, 0 && 0x3400, 0x0012 && 0, 0 && 0
    DB  0x0012 || 0x3400, 0 || 0x3400, 0x0012 || 0, 0 || 0
    DW  (2 * 3) + 4, 2 * (3 + 4)
    DW  $

    ; shifts vs 32bit evaluator, more (tricky) tests:
    DW  0xABCD1234 << 3, 0xABCD1234 shl 3
    DW  -1164413356 >> 19, -1164413356 shr 19   ; -1164413356 = 0xBA987654
    DW  0xBA987654 >> 19, 0xBA987654 shr 19
    DW  -1164413356 >>> 19, 0xBA987654 >>> 19

    DEVICE NONE
    ORG 0
    DW  0x1234
    DW  $$      ; error when not in device mode
    DW  { 0 }
    DW  {b 0 }
    DEVICE ZXSPECTRUM48
    ORG 0
    DW  0x1234
    DW  $$      ; should be OK
    DW  { 0 }
    DW  {b 0 }
